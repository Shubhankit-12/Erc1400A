/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace IERC1400TokensValidator {
  export type ValidateDataStruct = {
    token: PromiseOrValue<string>;
    payload: PromiseOrValue<BytesLike>;
    partition: PromiseOrValue<BytesLike>;
    operator: PromiseOrValue<string>;
    from: PromiseOrValue<string>;
    to: PromiseOrValue<string>;
    value: PromiseOrValue<BigNumberish>;
    data: PromiseOrValue<BytesLike>;
    operatorData: PromiseOrValue<BytesLike>;
  };

  export type ValidateDataStructOutput = [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    string,
    string
  ] & {
    token: string;
    payload: string;
    partition: string;
    operator: string;
    from: string;
    to: string;
    value: BigNumber;
    data: string;
    operatorData: string;
  };
}

export interface ERC1400TokensValidatorMockInterface extends utils.Interface {
  functions: {
    "addAllowlistAdmin(address,address)": FunctionFragment;
    "addAllowlisted(address,address)": FunctionFragment;
    "addBlocklistAdmin(address,address)": FunctionFragment;
    "addBlocklisted(address,address)": FunctionFragment;
    "addCertificateSigner(address,address)": FunctionFragment;
    "addPauser(address,address)": FunctionFragment;
    "balanceOnHold(address,address)": FunctionFragment;
    "balanceOnHoldByPartition(address,bytes32,address)": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "canValidate((address,bytes,bytes32,address,address,address,uint256,bytes,bytes))": FunctionFragment;
    "executeHold(address,bytes32,uint256,bytes32)": FunctionFragment;
    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)": FunctionFragment;
    "granularityByPartition(address,bytes32)": FunctionFragment;
    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "isAllowlistAdmin(address,address)": FunctionFragment;
    "isAllowlisted(address,address)": FunctionFragment;
    "isBlocklistAdmin(address,address)": FunctionFragment;
    "isBlocklisted(address,address)": FunctionFragment;
    "isCertificateSigner(address,address)": FunctionFragment;
    "isPauser(address,address)": FunctionFragment;
    "pause(address)": FunctionFragment;
    "paused(address)": FunctionFragment;
    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])": FunctionFragment;
    "releaseHold(address,bytes32)": FunctionFragment;
    "removeAllowlistAdmin(address,address)": FunctionFragment;
    "removeAllowlisted(address,address)": FunctionFragment;
    "removeBlocklistAdmin(address,address)": FunctionFragment;
    "removeBlocklisted(address,address)": FunctionFragment;
    "removeCertificateSigner(address,address)": FunctionFragment;
    "removePauser(address,address)": FunctionFragment;
    "renewHold(address,bytes32,uint256,bytes)": FunctionFragment;
    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)": FunctionFragment;
    "renounceAllowlistAdmin(address)": FunctionFragment;
    "renounceBlocklistAdmin(address)": FunctionFragment;
    "renounceCertificateSigner(address)": FunctionFragment;
    "renounceMinter(address)": FunctionFragment;
    "renouncePauser(address)": FunctionFragment;
    "retrieveHoldData(address,bytes32)": FunctionFragment;
    "retrieveTokenSetup(address)": FunctionFragment;
    "setGranularityByPartition(address,bytes32,uint256)": FunctionFragment;
    "spendableBalanceOf(address,address)": FunctionFragment;
    "spendableBalanceOfByPartition(address,bytes32,address)": FunctionFragment;
    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "totalSupplyOnHold(address)": FunctionFragment;
    "totalSupplyOnHoldByPartition(address,bytes32)": FunctionFragment;
    "unpause(address)": FunctionFragment;
    "usedCertificateNonce(address,address)": FunctionFragment;
    "usedCertificateSalt(address,bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addAllowlistAdmin"
      | "addAllowlisted"
      | "addBlocklistAdmin"
      | "addBlocklisted"
      | "addCertificateSigner"
      | "addPauser"
      | "balanceOnHold"
      | "balanceOnHoldByPartition"
      | "canImplementInterfaceForAddress"
      | "canValidate"
      | "executeHold"
      | "executeHoldAndKeepOpen"
      | "granularityByPartition"
      | "hold"
      | "holdFrom"
      | "holdFromWithExpirationDate"
      | "holdWithExpirationDate"
      | "isAllowlistAdmin"
      | "isAllowlisted"
      | "isBlocklistAdmin"
      | "isBlocklisted"
      | "isCertificateSigner"
      | "isPauser"
      | "pause"
      | "paused"
      | "preHoldFor"
      | "preHoldForWithExpirationDate"
      | "registerTokenSetup"
      | "releaseHold"
      | "removeAllowlistAdmin"
      | "removeAllowlisted"
      | "removeBlocklistAdmin"
      | "removeBlocklisted"
      | "removeCertificateSigner"
      | "removePauser"
      | "renewHold"
      | "renewHoldWithExpirationDate"
      | "renounceAllowlistAdmin"
      | "renounceBlocklistAdmin"
      | "renounceCertificateSigner"
      | "renounceMinter"
      | "renouncePauser"
      | "retrieveHoldData"
      | "retrieveTokenSetup"
      | "setGranularityByPartition"
      | "spendableBalanceOf"
      | "spendableBalanceOfByPartition"
      | "tokensToValidate"
      | "totalSupplyOnHold"
      | "totalSupplyOnHoldByPartition"
      | "unpause"
      | "usedCertificateNonce"
      | "usedCertificateSalt"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addAllowlistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addAllowlisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addCertificateSigner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "addPauser",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHold",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHoldByPartition",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "canValidate",
    values: [IERC1400TokensValidator.ValidateDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHold",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHoldAndKeepOpen",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "granularityByPartition",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "hold",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFromWithExpirationDate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdWithExpirationDate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCertificateSigner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isPauser",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "pause",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "paused",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldForWithExpirationDate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "registerTokenSetup",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseHold",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowlistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowlisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklistAdmin",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklisted",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removeCertificateSigner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "removePauser",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHold",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHoldWithExpirationDate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceAllowlistAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceBlocklistAdmin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceCertificateSigner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceMinter",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renouncePauser",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "retrieveHoldData",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "retrieveTokenSetup",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setGranularityByPartition",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOf",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOfByPartition",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensToValidate",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHold",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHoldByPartition",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "unpause",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateNonce",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateSalt",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "addAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPauser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHoldAndKeepOpen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "granularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hold", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "holdFrom", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "holdFromWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "holdWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isPauser", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "preHoldFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "preHoldForWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "renewHold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renewHoldWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renouncePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retrieveHoldData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retrieveTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGranularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOfByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensToValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateSalt",
    data: BytesLike
  ): Result;

  events: {
    "AllowlistAdminAdded(address,address)": EventFragment;
    "AllowlistAdminRemoved(address,address)": EventFragment;
    "AllowlistedAdded(address,address)": EventFragment;
    "AllowlistedRemoved(address,address)": EventFragment;
    "BlocklistAdminAdded(address,address)": EventFragment;
    "BlocklistAdminRemoved(address,address)": EventFragment;
    "BlocklistedAdded(address,address)": EventFragment;
    "BlocklistedRemoved(address,address)": EventFragment;
    "CertificateSignerAdded(address,address)": EventFragment;
    "CertificateSignerRemoved(address,address)": EventFragment;
    "HoldCreated(address,bytes32,bytes32,address,address,address,uint256,uint256,bytes32)": EventFragment;
    "HoldExecuted(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "HoldExecutedAndKeptOpen(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "HoldReleased(address,bytes32,address,uint8)": EventFragment;
    "HoldRenewed(address,bytes32,address,uint256,uint256)": EventFragment;
    "Paused(address,address)": EventFragment;
    "PauserAdded(address,address)": EventFragment;
    "PauserRemoved(address,address)": EventFragment;
    "Unpaused(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AllowlistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecutedAndKeptOpen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldReleased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldRenewed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

export interface AllowlistAdminAddedEventObject {
  token: string;
  account: string;
}
export type AllowlistAdminAddedEvent = TypedEvent<
  [string, string],
  AllowlistAdminAddedEventObject
>;

export type AllowlistAdminAddedEventFilter =
  TypedEventFilter<AllowlistAdminAddedEvent>;

export interface AllowlistAdminRemovedEventObject {
  token: string;
  account: string;
}
export type AllowlistAdminRemovedEvent = TypedEvent<
  [string, string],
  AllowlistAdminRemovedEventObject
>;

export type AllowlistAdminRemovedEventFilter =
  TypedEventFilter<AllowlistAdminRemovedEvent>;

export interface AllowlistedAddedEventObject {
  token: string;
  account: string;
}
export type AllowlistedAddedEvent = TypedEvent<
  [string, string],
  AllowlistedAddedEventObject
>;

export type AllowlistedAddedEventFilter =
  TypedEventFilter<AllowlistedAddedEvent>;

export interface AllowlistedRemovedEventObject {
  token: string;
  account: string;
}
export type AllowlistedRemovedEvent = TypedEvent<
  [string, string],
  AllowlistedRemovedEventObject
>;

export type AllowlistedRemovedEventFilter =
  TypedEventFilter<AllowlistedRemovedEvent>;

export interface BlocklistAdminAddedEventObject {
  token: string;
  account: string;
}
export type BlocklistAdminAddedEvent = TypedEvent<
  [string, string],
  BlocklistAdminAddedEventObject
>;

export type BlocklistAdminAddedEventFilter =
  TypedEventFilter<BlocklistAdminAddedEvent>;

export interface BlocklistAdminRemovedEventObject {
  token: string;
  account: string;
}
export type BlocklistAdminRemovedEvent = TypedEvent<
  [string, string],
  BlocklistAdminRemovedEventObject
>;

export type BlocklistAdminRemovedEventFilter =
  TypedEventFilter<BlocklistAdminRemovedEvent>;

export interface BlocklistedAddedEventObject {
  token: string;
  account: string;
}
export type BlocklistedAddedEvent = TypedEvent<
  [string, string],
  BlocklistedAddedEventObject
>;

export type BlocklistedAddedEventFilter =
  TypedEventFilter<BlocklistedAddedEvent>;

export interface BlocklistedRemovedEventObject {
  token: string;
  account: string;
}
export type BlocklistedRemovedEvent = TypedEvent<
  [string, string],
  BlocklistedRemovedEventObject
>;

export type BlocklistedRemovedEventFilter =
  TypedEventFilter<BlocklistedRemovedEvent>;

export interface CertificateSignerAddedEventObject {
  token: string;
  account: string;
}
export type CertificateSignerAddedEvent = TypedEvent<
  [string, string],
  CertificateSignerAddedEventObject
>;

export type CertificateSignerAddedEventFilter =
  TypedEventFilter<CertificateSignerAddedEvent>;

export interface CertificateSignerRemovedEventObject {
  token: string;
  account: string;
}
export type CertificateSignerRemovedEvent = TypedEvent<
  [string, string],
  CertificateSignerRemovedEventObject
>;

export type CertificateSignerRemovedEventFilter =
  TypedEventFilter<CertificateSignerRemovedEvent>;

export interface HoldCreatedEventObject {
  token: string;
  holdId: string;
  partition: string;
  sender: string;
  recipient: string;
  notary: string;
  value: BigNumber;
  expiration: BigNumber;
  secretHash: string;
}
export type HoldCreatedEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string
  ],
  HoldCreatedEventObject
>;

export type HoldCreatedEventFilter = TypedEventFilter<HoldCreatedEvent>;

export interface HoldExecutedEventObject {
  token: string;
  holdId: string;
  notary: string;
  heldValue: BigNumber;
  transferredValue: BigNumber;
  secret: string;
}
export type HoldExecutedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, string],
  HoldExecutedEventObject
>;

export type HoldExecutedEventFilter = TypedEventFilter<HoldExecutedEvent>;

export interface HoldExecutedAndKeptOpenEventObject {
  token: string;
  holdId: string;
  notary: string;
  heldValue: BigNumber;
  transferredValue: BigNumber;
  secret: string;
}
export type HoldExecutedAndKeptOpenEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, string],
  HoldExecutedAndKeptOpenEventObject
>;

export type HoldExecutedAndKeptOpenEventFilter =
  TypedEventFilter<HoldExecutedAndKeptOpenEvent>;

export interface HoldReleasedEventObject {
  token: string;
  holdId: string;
  notary: string;
  status: number;
}
export type HoldReleasedEvent = TypedEvent<
  [string, string, string, number],
  HoldReleasedEventObject
>;

export type HoldReleasedEventFilter = TypedEventFilter<HoldReleasedEvent>;

export interface HoldRenewedEventObject {
  token: string;
  holdId: string;
  notary: string;
  oldExpiration: BigNumber;
  newExpiration: BigNumber;
}
export type HoldRenewedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  HoldRenewedEventObject
>;

export type HoldRenewedEventFilter = TypedEventFilter<HoldRenewedEvent>;

export interface PausedEventObject {
  token: string;
  account: string;
}
export type PausedEvent = TypedEvent<[string, string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PauserAddedEventObject {
  token: string;
  account: string;
}
export type PauserAddedEvent = TypedEvent<
  [string, string],
  PauserAddedEventObject
>;

export type PauserAddedEventFilter = TypedEventFilter<PauserAddedEvent>;

export interface PauserRemovedEventObject {
  token: string;
  account: string;
}
export type PauserRemovedEvent = TypedEvent<
  [string, string],
  PauserRemovedEventObject
>;

export type PauserRemovedEventFilter = TypedEventFilter<PauserRemovedEvent>;

export interface UnpausedEventObject {
  token: string;
  account: string;
}
export type UnpausedEvent = TypedEvent<[string, string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface ERC1400TokensValidatorMock extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ERC1400TokensValidatorMockInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balanceOnHold(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    canValidate(
      data: IERC1400TokensValidator.ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    executeHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeHoldAndKeepOpen(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    granularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    hold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    holdFrom(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    holdFromWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    holdWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    pause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paused(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    preHoldFor(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    preHoldForWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    registerTokenSetup(
      token: PromiseOrValue<string>,
      certificateActivated: PromiseOrValue<BigNumberish>,
      allowlistActivated: PromiseOrValue<boolean>,
      blocklistActivated: PromiseOrValue<boolean>,
      granularityByPartitionActivated: PromiseOrValue<boolean>,
      holdsActivated: PromiseOrValue<boolean>,
      operators: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    releaseHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removePauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renewHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renewHoldWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      expiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceAllowlistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceBlocklistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceCertificateSigner(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceMinter(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renouncePauser(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    retrieveHoldData(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number
      ] & {
        partition: string;
        sender: string;
        recipient: string;
        notary: string;
        value: BigNumber;
        expiration: BigNumber;
        secretHash: string;
        secret: string;
        status: number;
      }
    >;

    retrieveTokenSetup(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

    setGranularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      granularity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    spendableBalanceOf(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    spendableBalanceOfByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tokensToValidate(
      payload: PromiseOrValue<BytesLike>,
      partition: PromiseOrValue<BytesLike>,
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      operatorData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    totalSupplyOnHold(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalSupplyOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    unpause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    usedCertificateNonce(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    usedCertificateSalt(
      token: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  addAllowlistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addAllowlisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addBlocklistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addBlocklisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addCertificateSigner(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addPauser(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balanceOnHold(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceOnHoldByPartition(
    token: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  canImplementInterfaceForAddress(
    interfaceHash: PromiseOrValue<BytesLike>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  canValidate(
    data: IERC1400TokensValidator.ValidateDataStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  executeHold(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    secret: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeHoldAndKeepOpen(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    secret: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  granularityByPartition(
    token: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hold(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    timeToExpiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  holdFrom(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    timeToExpiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  holdFromWithExpirationDate(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    sender: PromiseOrValue<string>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    expiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  holdWithExpirationDate(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    expiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isAllowlistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isAllowlisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isCertificateSigner(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isPauser(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  pause(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paused(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  preHoldFor(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    timeToExpiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  preHoldForWithExpirationDate(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    recipient: PromiseOrValue<string>,
    notary: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    value: PromiseOrValue<BigNumberish>,
    expiration: PromiseOrValue<BigNumberish>,
    secretHash: PromiseOrValue<BytesLike>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  registerTokenSetup(
    token: PromiseOrValue<string>,
    certificateActivated: PromiseOrValue<BigNumberish>,
    allowlistActivated: PromiseOrValue<boolean>,
    blocklistActivated: PromiseOrValue<boolean>,
    granularityByPartitionActivated: PromiseOrValue<boolean>,
    holdsActivated: PromiseOrValue<boolean>,
    operators: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  releaseHold(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeAllowlistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeAllowlisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeBlocklistAdmin(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeBlocklisted(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeCertificateSigner(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removePauser(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renewHold(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    timeToExpiration: PromiseOrValue<BigNumberish>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renewHoldWithExpirationDate(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    expiration: PromiseOrValue<BigNumberish>,
    certificate: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceAllowlistAdmin(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceBlocklistAdmin(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceCertificateSigner(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceMinter(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renouncePauser(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  retrieveHoldData(
    token: PromiseOrValue<string>,
    holdId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      string,
      number
    ] & {
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
    }
  >;

  retrieveTokenSetup(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

  setGranularityByPartition(
    token: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    granularity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  spendableBalanceOf(
    token: PromiseOrValue<string>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  spendableBalanceOfByPartition(
    token: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokensToValidate(
    payload: PromiseOrValue<BytesLike>,
    partition: PromiseOrValue<BytesLike>,
    operator: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    operatorData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  totalSupplyOnHold(
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalSupplyOnHoldByPartition(
    token: PromiseOrValue<string>,
    partition: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  unpause(
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  usedCertificateNonce(
    token: PromiseOrValue<string>,
    sender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  usedCertificateSalt(
    token: PromiseOrValue<string>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    addAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    addPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    balanceOnHold(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    canValidate(
      data: IERC1400TokensValidator.ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeHoldAndKeepOpen(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    granularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    holdFrom(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    holdFromWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    holdWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    pause(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    paused(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    preHoldFor(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    preHoldForWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    registerTokenSetup(
      token: PromiseOrValue<string>,
      certificateActivated: PromiseOrValue<BigNumberish>,
      allowlistActivated: PromiseOrValue<boolean>,
      blocklistActivated: PromiseOrValue<boolean>,
      granularityByPartitionActivated: PromiseOrValue<boolean>,
      holdsActivated: PromiseOrValue<boolean>,
      operators: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    releaseHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    removeAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removeCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    removePauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renewHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    renewHoldWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      expiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    renounceAllowlistAdmin(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceBlocklistAdmin(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceCertificateSigner(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceMinter(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    renouncePauser(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    retrieveHoldData(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number
      ] & {
        partition: string;
        sender: string;
        recipient: string;
        notary: string;
        value: BigNumber;
        expiration: BigNumber;
        secretHash: string;
        secret: string;
        status: number;
      }
    >;

    retrieveTokenSetup(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number, boolean, boolean, boolean, boolean, string[]]>;

    setGranularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      granularity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    spendableBalanceOf(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    spendableBalanceOfByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokensToValidate(
      payload: PromiseOrValue<BytesLike>,
      partition: PromiseOrValue<BytesLike>,
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      operatorData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    totalSupplyOnHold(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupplyOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpause(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    usedCertificateNonce(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    usedCertificateSalt(
      token: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "AllowlistAdminAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistAdminAddedEventFilter;
    AllowlistAdminAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistAdminAddedEventFilter;

    "AllowlistAdminRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistAdminRemovedEventFilter;
    AllowlistAdminRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistAdminRemovedEventFilter;

    "AllowlistedAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistedAddedEventFilter;
    AllowlistedAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistedAddedEventFilter;

    "AllowlistedRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistedRemovedEventFilter;
    AllowlistedRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): AllowlistedRemovedEventFilter;

    "BlocklistAdminAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistAdminAddedEventFilter;
    BlocklistAdminAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistAdminAddedEventFilter;

    "BlocklistAdminRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistAdminRemovedEventFilter;
    BlocklistAdminRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistAdminRemovedEventFilter;

    "BlocklistedAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistedAddedEventFilter;
    BlocklistedAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistedAddedEventFilter;

    "BlocklistedRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistedRemovedEventFilter;
    BlocklistedRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): BlocklistedRemovedEventFilter;

    "CertificateSignerAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): CertificateSignerAddedEventFilter;
    CertificateSignerAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): CertificateSignerAddedEventFilter;

    "CertificateSignerRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): CertificateSignerRemovedEventFilter;
    CertificateSignerRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): CertificateSignerRemovedEventFilter;

    "HoldCreated(address,bytes32,bytes32,address,address,address,uint256,uint256,bytes32)"(
      token?: PromiseOrValue<string> | null,
      holdId?: PromiseOrValue<BytesLike> | null,
      partition?: null,
      sender?: null,
      recipient?: null,
      notary?: PromiseOrValue<string> | null,
      value?: null,
      expiration?: null,
      secretHash?: null
    ): HoldCreatedEventFilter;
    HoldCreated(
      token?: PromiseOrValue<string> | null,
      holdId?: PromiseOrValue<BytesLike> | null,
      partition?: null,
      sender?: null,
      recipient?: null,
      notary?: PromiseOrValue<string> | null,
      value?: null,
      expiration?: null,
      secretHash?: null
    ): HoldCreatedEventFilter;

    "HoldExecuted(address,bytes32,address,uint256,uint256,bytes32)"(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedEventFilter;
    HoldExecuted(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedEventFilter;

    "HoldExecutedAndKeptOpen(address,bytes32,address,uint256,uint256,bytes32)"(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedAndKeptOpenEventFilter;
    HoldExecutedAndKeptOpen(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      heldValue?: null,
      transferredValue?: null,
      secret?: null
    ): HoldExecutedAndKeptOpenEventFilter;

    "HoldReleased(address,bytes32,address,uint8)"(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      status?: null
    ): HoldReleasedEventFilter;
    HoldReleased(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      status?: null
    ): HoldReleasedEventFilter;

    "HoldRenewed(address,bytes32,address,uint256,uint256)"(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      oldExpiration?: null,
      newExpiration?: null
    ): HoldRenewedEventFilter;
    HoldRenewed(
      token?: PromiseOrValue<string> | null,
      holdId?: null,
      notary?: PromiseOrValue<string> | null,
      oldExpiration?: null,
      newExpiration?: null
    ): HoldRenewedEventFilter;

    "Paused(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: null
    ): PausedEventFilter;
    Paused(
      token?: PromiseOrValue<string> | null,
      account?: null
    ): PausedEventFilter;

    "PauserAdded(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): PauserAddedEventFilter;
    PauserAdded(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): PauserAddedEventFilter;

    "PauserRemoved(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): PauserRemovedEventFilter;
    PauserRemoved(
      token?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null
    ): PauserRemovedEventFilter;

    "Unpaused(address,address)"(
      token?: PromiseOrValue<string> | null,
      account?: null
    ): UnpausedEventFilter;
    Unpaused(
      token?: PromiseOrValue<string> | null,
      account?: null
    ): UnpausedEventFilter;
  };

  estimateGas: {
    addAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balanceOnHold(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    canValidate(
      data: IERC1400TokensValidator.ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executeHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeHoldAndKeepOpen(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    granularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    holdFrom(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    holdFromWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    holdWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    pause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paused(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    preHoldFor(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    preHoldForWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    registerTokenSetup(
      token: PromiseOrValue<string>,
      certificateActivated: PromiseOrValue<BigNumberish>,
      allowlistActivated: PromiseOrValue<boolean>,
      blocklistActivated: PromiseOrValue<boolean>,
      granularityByPartitionActivated: PromiseOrValue<boolean>,
      holdsActivated: PromiseOrValue<boolean>,
      operators: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    releaseHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removePauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renewHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renewHoldWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      expiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceAllowlistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceBlocklistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceCertificateSigner(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceMinter(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renouncePauser(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    retrieveHoldData(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    retrieveTokenSetup(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setGranularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      granularity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    spendableBalanceOf(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    spendableBalanceOfByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokensToValidate(
      payload: PromiseOrValue<BytesLike>,
      partition: PromiseOrValue<BytesLike>,
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      operatorData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    totalSupplyOnHold(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupplyOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    usedCertificateNonce(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    usedCertificateSalt(
      token: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balanceOnHold(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: PromiseOrValue<BytesLike>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    canValidate(
      data: IERC1400TokensValidator.ValidateDataStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeHoldAndKeepOpen(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      secret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    granularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    holdFrom(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    holdFromWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      sender: PromiseOrValue<string>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    holdWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isPauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paused(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    preHoldFor(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    preHoldForWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      recipient: PromiseOrValue<string>,
      notary: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      value: PromiseOrValue<BigNumberish>,
      expiration: PromiseOrValue<BigNumberish>,
      secretHash: PromiseOrValue<BytesLike>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    registerTokenSetup(
      token: PromiseOrValue<string>,
      certificateActivated: PromiseOrValue<BigNumberish>,
      allowlistActivated: PromiseOrValue<boolean>,
      blocklistActivated: PromiseOrValue<boolean>,
      granularityByPartitionActivated: PromiseOrValue<boolean>,
      holdsActivated: PromiseOrValue<boolean>,
      operators: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    releaseHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeAllowlistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeAllowlisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeBlocklistAdmin(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeBlocklisted(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeCertificateSigner(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removePauser(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renewHold(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      timeToExpiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renewHoldWithExpirationDate(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      expiration: PromiseOrValue<BigNumberish>,
      certificate: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceAllowlistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceBlocklistAdmin(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceCertificateSigner(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceMinter(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renouncePauser(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    retrieveHoldData(
      token: PromiseOrValue<string>,
      holdId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    retrieveTokenSetup(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setGranularityByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      granularity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    spendableBalanceOf(
      token: PromiseOrValue<string>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    spendableBalanceOfByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokensToValidate(
      payload: PromiseOrValue<BytesLike>,
      partition: PromiseOrValue<BytesLike>,
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      operatorData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    totalSupplyOnHold(
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupplyOnHoldByPartition(
      token: PromiseOrValue<string>,
      partition: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unpause(
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    usedCertificateNonce(
      token: PromiseOrValue<string>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    usedCertificateSalt(
      token: PromiseOrValue<string>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
